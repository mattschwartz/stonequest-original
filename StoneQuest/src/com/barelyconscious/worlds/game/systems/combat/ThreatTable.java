package com.barelyconscious.worlds.game.systems.combat;

import com.barelyconscious.worlds.entity.EntityActor;

import java.util.HashMap;
import java.util.Map;

/**
 * Combat encounters are from the time entities engage in combat until all entities have exited
 * combat, either by running away or dying. The threat table is a data structure that keeps track
 * of which entities are attacking which other entities. The threat table is used to determine
 * which entity an enemy will attack.
 * <p>
 * How this works
 * - As soon as an entity attacks another entity, a combat encounter is started and the initiating
 * actor is added to the threat table along with the entity it attacked and any other entities that the
 * defending entity calls to battle.
 * - Throughout the combat encounter, as threat-generating abilities are used, the threat table is
 * updated to reflect the new threat against all applicable entities. Some abilities generate threat
 * across all entities in the combat encounter, while others generate threat against a single entity.
 * - The threat table is used by AI to determine which entity to attack. The AI will attack the entity
 * with the highest threat in the combat encounter.
 */
public class ThreatTable {

    // this table maps threat between defenders and attackers
    // key=defender, value=map<attacker, threat>
    private final Map<EntityActor, Map<EntityActor, Double>> defenderThreatTable;

    public ThreatTable() {
        defenderThreatTable = new HashMap<>();
    }

    /**
     * Answers the question of how much threat has attacker generated against defender?
     *
     * @param attacker the attacker entity, the entity that defender is querying about
     * @param defender the defending entity, making the query
     * @return the amount of threat that attacker has generated against defender
     */
    public double getThreat(EntityActor attacker, EntityActor defender) {
        return defenderThreatTable.get(defender).get(attacker);
    }

    /**
     * @param defender the defending entity
     * @return the entity that has generated the most threat against defender
     */
    public EntityActor getHighestThreatActor(EntityActor defender) {
        double highestThreat = 0;
        EntityActor highestThreatActor = null;

        for (var actor : defenderThreatTable.get(defender).keySet()) {
            if (defenderThreatTable.get(defender).get(actor) > highestThreat) {
                highestThreat = defenderThreatTable.get(defender).get(actor);
                highestThreatActor = actor;
            }
        }

        return highestThreatActor;
    }

    /**
     * Adds the threat generated by attacker to the defending actor's threat table.
     * <p>
     * Bill generates 5 threat against Bob -> addThreat(bill, bob, 5);
     *
     * @param attacker the entity that generated the threat
     * @param defender the entity that the threat is against
     * @param threat   the amount of threat generated
     */
    public void addThreat(EntityActor attacker, EntityActor defender, double threat) {
        if (!defenderThreatTable.containsKey(defender)) {
            addCombatant(defender);
        }
        if (!defenderThreatTable.containsKey(attacker)) {
            addCombatant(attacker);
        }

        defenderThreatTable.get(defender)
            .put(attacker, defenderThreatTable.get(defender).get(attacker) + threat);
    }

    public void addCombatant(EntityActor actor) {
        if (!defenderThreatTable.containsKey(actor)) {
            defenderThreatTable.put(actor, new HashMap<>());
        }

        for (var otherActor : defenderThreatTable.keySet()) {
            defenderThreatTable.get(actor).put(otherActor, 0.0);
        }

        // update mapping against all the other actors
        for (var otherActor : defenderThreatTable.keySet()) {
            defenderThreatTable.get(otherActor).put(actor, 0.0);
        }
    }

    /**
     * Clears the threat of the attacker against all its defenders
     *
     * @param attacker the entity dropping threat
     */
    public void clearThreat(EntityActor attacker) {
        if (!defenderThreatTable.containsKey(attacker)) {
            addCombatant(attacker);
        }

        for (var defender : defenderThreatTable.keySet()) {
            defenderThreatTable.get(defender).put(attacker, 0.0);
        }
    }
}
